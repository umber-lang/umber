# max_consecutive_sum
# maxConsecutiveSum
# TODO: decide on snake_case vs camelCase

sig
  max_consecutive_sum : Number a, Iterable t => Int -> t a -> a

max_consecutive_sum k nums = maximum (map (windows k nums) ~f:sum)

# max_conseuctive_sum k nums = nums.(windows k).(map ~f:sum).maximum

# . can maybe be a syntactic sugar for applying the function (maybe with some
# added magic to deal with namespacing) - e.g. it looks only at functions
# defined in the module where the type is defined (ofc to do this it needs
# to know what the type is)

# ^ this syntax looks nice, but the following one is better on multiple lines
# the first one gets ugly managing parentheses

max_conseuctive_sum nums k = nums |> windows k |> map ~f:sum |> maximum

# also note for currying, maybe consider making all arguments named, but putting
# them optional? And maybe some kind of marker for currying? e.g. just a ~ at the end to say "I'm done"
# instead of needing unit

# max_consecutive_sum : Number a, Iterable t => k:Int, nums:t a -> Int

# probably nah, but it's an idea