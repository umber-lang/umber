# FIXME: Allow explicit imports of the prelude that hide things.
# e.g. `import Prelude without Option`
# This seems nontrivial since we have to look through local imports for prelude imports,
# then do the prelude import, then resolve the local imports. Also, imports of `Prelude`
# of `Std.Prelude` might not actually refer to the prelude, right? Unless, we force import
# paths to be absolute or explicitly relative. That sounds like a good idea!

module : {
  type Option a =
    | None
    | Some a
    #impl Functor, Applicative, Monad
    # TODO: what about stuff like (Eq a) => Eq (Option a) ?
    # Maybe the impls should just be exposed automatically
    # (private impls cause problems anyway)
    # Could also have them listed in a block here
    # If they aren't listed here, maybe a doc tool just generates them?
    # TODO: replace `impl` with `@deriving`
    # Also add syntax for `@[annotation_expressions]`
    # and `@@toplevel_annotations` (actually, scrapped this)
}