# Mutual recursion within a module is allowed for both types and let-bindings

# Types can be used before being defined
val f : Forest a
let f = Nil

# FIXME: Why does this module generate functions/values for Nil and Cons?
# It should be using the ones from the Prelude, not defining its own.

let sum_forest =
  let loop acc forest = match forest
    # TODO: syntactic sugar for lists and other sequences
    | Nil -> acc
    | Cons tree trees -> loop (acc + sum_tree tree) trees
  in
  # FIXME: This function closes over `loop`, which isn't quite right. The closure check
  # should exclude variables which will be hoisted to toplevel (locally defined
  # functions)
  \forest -> loop 0 forest

let sum_tree = match
  | Leaf -> 0
  | Node x forest -> x + sum_forest forest

type alias Forest a = List (Tree a)
type Tree a =
  | Leaf
  | Node a (Forest a)

# FIXME: This segfaults due to use of uninitialized memory
#let () = 
#  let tree = Node 1 (Cons Leaf (Cons (Node 17 Nil) Nil)) in
#  print_int (sum_tree tree)

let even x = if x == 0 then True else odd (x - 1)
let odd x = if x == 0 then False else even (x - 1)

# Test non-recursive let statements as well
let number =
  let number = 5 in  # This shadows the outer `number`, which is fine
  let' number = number + number in
  number

# TODO: add tests for use between submodules
# e.g. imports to/from, usage between the parent and child
# ^ make the above module `Tree` and have mutual usage with the parent