effect Read = {
  val ask : () -> Int
}

let read : () -> <Read> Int = ask

let read_and_add () = ask () + ask ()

let run_both f g x = (f x, g x)

let foo () = run_both (\x -> x + read_and_add ()) print_int 5

# TODO: Add warning for unreachable handler branches
let _ =
  handle 5
  | <ask ()> -> 6

let _ =
  handle read_and_add ()
  | <ask ()> -> resume 1

let _value_branch =
  handle foo ()
  | (x, ()) -> x
  | <ask ()> -> resume 0

let _nested_handler =
  handle
    (handle ask ()
     | x -> x + 1
     | <ask ()> -> resume 5)
  | <ask ()> -> resume 7

let higher_order_handler f =
  handle f ()
  | <ask ()> -> ()

let _ =
  higher_order_handler (\() -> ignore (ask ()))

# FIXME: Move these to separate tests
# let handle_state : a, (() -> <State a> b) -> (a, b) = \init f ->
#  (handle f ()
#  | x -> (\s -> (s, x))
#  | <get ()> -> (\s -> (resume s) s)
#  | <set s> -> (\_ -> (resume ()) s))
#  init

# CPS conversion?
let read_and_add : () -> <Read> Int = ask () + ask ()
let _ =
  handle 
   (let x = read_and_add () in
    x + 2)
  | <ask ()> -> resume 1

# Becomes:
let read_and_add : (), (Int -> a) -> a = 
  
let _ =
  handle 
   (read_and_add () (fun x ->
    x + 2))
  | <ask ()> -> resume 1

# Or, what if the runtime just maintained the stack of handlers separately?
#
# Then, when you would call a function, you call into the runtime 