effect Read = {
  # TODO: Remove this hack by either rethinking the trait bound syntax or fixing the parser
  val ask : () => () -> Int
}

val read : () => () -> <Read> Int
let read = ask

let read_and_add () = ask () + ask ()

let run_both f g x = (f x, g x)

let foo () = run_both (\x -> x + read_and_add ()) print_int 5

# TODO: Add warning for unreachable handler branches
let _ =
  handle 5
  | <ask ()> -> 6

let _ =
  handle read_and_add ()
  | <ask ()> -> resume 1

let _value_branch =
  handle foo ()
  | (x, ()) -> x
  | <ask ()> -> resume 0

let _nested_handler =
  handle
    (handle ask ()
     | x -> x + 1
     | <ask ()> -> resume 5)
  | <ask ()> -> resume 7

# FIXME: Wrong type inferred
# Expected:
# `(() -> <Read,e> ()) -> <e> ()` (importantly, e does not include Read)
# Also sound, though not a precise enough type:
# `(() -> <e> ()) -> <e> ()` (doesn't show that Read is handled, bad, but is still sound)
# Or what about this:
# `(() -> <e> ()) -> <e - Read> ()` (if we could represent effect differences)
# (we could equivalently use the same "effect var does not include effect" idea
# and mint an anonymous var e2 to be basically e - Read)
# Actual:
# `(() -> <&> ()) -> <> ()`
# which is clearly wrong. It eliminates all effects from the argument.
#
# Importantly, we might need to somehow propagate the implicit constraint that e does not
# include Read when instantiating the type. (Or maybe it's fine if we don't)
# 
# To get this:
# Set f : (() -> <e1> ())
# Constrain e1 <: Read + e2
# Get e1 := Read + e3
let higher_order_handler f =
  handle f ()
  | <ask ()> -> ()

# TODO: Add a test that you can't handle functions which aren't operations

# FIXME: Move these to separate tests
# let reraise f =
#   let result =
#     handle f ()
#     | value -> Ok value
#     | <raise exn> -> Error exn
#   in
#   match result
#   | Ok value -> value
#   | Error exn -> raise exn

# val handle_state : a, (() -> <State a> b) -> (a, b)
# let handle_state init f =
#  (handle f ()
#  | x -> (\s -> (s, x))
#  | <get ()> -> (\s -> (resume s) s)
#  | <set s> -> (\_ -> (resume ()) s))
#  init